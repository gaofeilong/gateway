//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : @Config File Parse
//  @ File Name : IniParser.cpp
//  @ Date : 2011-8-22
//  @ Author : @gfl


#include <fstream>
#include <iostream>
#include "Utils/Log/Log.h"
#include "Config/IniParser.h"

IniParser::IniParser(const string& cfgFile):m_ConfigFile(cfgFile)
{
}

IniParser::~IniParser()
{
}

void IniParser::Trim(string &s) 
{       
        s.erase(0,s.find_first_not_of(" \t\n"));
        s.erase(s.find_last_not_of(" \t\n") + 1);
        string tempStr;
        if (s[0] == '[' || s[0] == ';' || s[0] == '#') {               //域和注释不处理
                return; 
        } else {                                        //entry
                tempStr.clear();
                string::const_iterator sIter = s.begin();
                for ( ; sIter != s.end(); ++sIter) {
                        if (*sIter != ' ') {
                                tempStr += *sIter;
                        } 
                }
                s = tempStr;
        }
}

int IniParser::Init()
{       
        ifstream fin(m_ConfigFile.c_str());
        if (!fin.good()) {
                LOG_ERROR("open config file error! path=" << m_ConfigFile);
                return -1;
        }

        size_t pos;
        string line;
        vector<string> comments;
        while (getline(fin,line)) {
                Trim(line);
                if (line[0] == '#' || line[0] == ';') {
                        comments.push_back(line);
                } else if (line[0] == '[') {
                        IniSection inisection;
                        inisection.Name = line;
                        inisection.Comment = comments;
                        m_Sections.push_back(inisection);
                        comments.clear();
                } else if ((pos = line.find('=')) != string::npos) {
                        string key;
                        string val;
                        IniEntry entry;

                        entry.Commnet = comments;
                        entry.Value   = line.substr(pos + 1);   //'='之后的部分
                        entry.Key     = line.substr(0, pos);    //'='之前的部分
                        m_Sections[m_Sections.size() - 1].Entry.push_back(entry);
                        comments.clear();
                } else {
                        continue;
                }
        }
        fin.close();
        return 0;
}

int IniParser::Write()
{

        vector<IniSection>::iterator secIter = m_Sections.begin();
        for ( ; secIter != m_Sections.end(); ++secIter) {       //遍历域
                if (secIter->Name == "[mail function]") {                   
                        /* LOG_INFO(secIter->Name); */
                        vector<IniEntry>::iterator entryIter 
                                = secIter->Entry.begin();
                        for ( ; entryIter != secIter->Entry.end(); 
                                        ++entryIter) {          //遍历该域中的字段
                                if (entryIter->Key == "SMTP") {
                                        /* LOG_INFO(entryIter->Key << 
                                                '=' << entryIter->Value); */
                                }
                        }
                }
        }

        FILE* fout = fopen(m_ConfigFile.c_str(),"w");                 
        if (NULL == fout) {
                LOG_ERROR("open stream error"); 
                return -1;
        }
        
        vector<IniSection>::iterator iter = m_Sections.begin();
        for ( ; iter != m_Sections.end(); ++iter) {
                if (!iter->Comment.empty() ) {
                        vector<string>::iterator i_coms = iter->Comment.begin();
                        for ( ; i_coms != iter->Comment.end(); ++i_coms) {
                                fprintf(fout, "%s\n", i_coms->c_str() );
                        }
                }

                fprintf(fout, "%s\n\n", iter->Name.c_str() );
                vector<IniEntry>::iterator i_ent = iter->Entry.begin();
                for( ; i_ent != iter->Entry.end(); ++i_ent) {
                        if (!i_ent->Commnet.empty() ) {
                                vector<string>::iterator i_come 
                                                = i_ent->Commnet.begin(); 
                                for( ;i_come != i_ent->Commnet.end(); ++i_come) {
                                        fprintf(fout,"%s\n", i_come->c_str() );
                                }
                        }
                        fprintf(fout,"%s=%s\n\n",i_ent->Key.c_str(), 
                                        i_ent->Value.c_str());
                }
        }
        if (fclose(fout) != 0) {
                LOG_ERROR("close stream error"); 
        }
        return 0;
}

size_t IniParser::GetSize(const string& field)
{
        const string fieldName = "[" + field + "]";                     //域名
        vector<IniSection>::iterator sectionIter = m_Sections.begin();
        for ( ; sectionIter != m_Sections.end(); ++sectionIter) {      
                if (fieldName == sectionIter->Name) {                   //找到域
                        return sectionIter->Entry.size();
                } 
        }
        return -1;
}

int IniParser::GetVal(const string& field, const string& key, string& val)
{
        const string fieldName = "[" + field + "]";                     //域名

        vector<IniSection>::iterator sectionIter = m_Sections.begin();
        for ( ; sectionIter != m_Sections.end(); ++sectionIter) { 
                /* LOG_INFO(sectionIter->Name); */
                if (fieldName == sectionIter->Name) {                   //找到域
                        vector<IniEntry>::iterator entryIter 
                                = sectionIter->Entry.begin();                                
                        for ( ; entryIter != sectionIter->Entry.end(); 
                                ++entryIter) {                  //遍历该域中的字段
                                /* LOG_INFO(fieldName << " " << entryIter->Key); */
                                if (key == entryIter->Key) {    //找到字段
                                        val  = entryIter->Value; 
                                        break;
                                }
                        }
                        if (entryIter == sectionIter->Entry.end()) {
                                return -1;                       
                        }
                } 
        }
        return 0;
}

int IniParser::SetVal(const string& field, const string& key, const string& val)
{
        bool isSectionExist = false;                    //域是否在配置文件中存在 
        bool isEntryExist   = false;                    //条目是否在配置文件中存在 
        const string fieldName = "[" + field + "]";

        vector<IniSection>::iterator sectionIter = m_Sections.begin();
        for ( ; sectionIter != m_Sections.end(); ++sectionIter) {       //遍历域
                if (fieldName == sectionIter->Name) {                   //找到要设置的域
                        isSectionExist = true;
                        vector<IniEntry>::iterator entryIter 
                                        = sectionIter->Entry.begin();
                        for ( ; entryIter != sectionIter->Entry.end(); 
                                ++entryIter) {                  //遍历该域中的字段
                                if (key == entryIter->Key) {    //找到要设置的字段
                                        entryIter->Value = val;
                                        isEntryExist = true;
                                }
                        }
                } 
        }

        if (!isEntryExist) {                                                                            
                if (isSectionExist) {                           //域存在但字段不存在
                        vector<IniSection>::iterator sectionIter = m_Sections.begin();
                        for ( ; sectionIter != m_Sections.end(); ++sectionIter) {    
                                if (fieldName == sectionIter->Name) { 
                                        IniEntry   entry;
                                        entry.Key   = key;
                                        entry.Value = val;
                                        sectionIter->Entry.push_back(entry);
                                } 
                        }

                } else {                                        //域和字段都不存在
                        IniEntry   entry;
                        IniSection section;
                        entry.Key   = key;
                        entry.Value = val;
                        section.Name  = "[" + field + "]";
                        section.Entry.push_back(entry);
                        m_Sections.push_back(section);                                                         
                }
        } 
        return Write();
}
